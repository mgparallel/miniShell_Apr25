/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TODO_GABRIEL                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gapujol- <gapujol-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 20:05:52 by gapujol-          #+#    #+#             */
/*   Updated: 2025/07/17 19:15:16 by gapujol-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	pipe_heredoc(char *delimiter, t_files *env, int exit_status, int in_quote)
{
	char	*line;
	int		pipefd[2];
	pid_t	pid;
	int		status;

	if (pipe(pipefd) == -1)
		return (perror("pipe"), -1);
	pid = fork();
	if (pid == -1)
		return (perror("fork"), close(pipefd[0]), close(pipefd[1]), -1);
	if (pid == 0)
	{
		close(pipefd[0]);
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_IGN);
		while (1)
		{
			line = readline("> ");
			if (!line)
				ft_putstr_fd("warning: heredoc delimited by end-of-file\n", 2);
			if (!line || ft_strcmp(line, delimiter) == 0)
				break ;
			if (!in_quote)
				expand_var_heredoc(&line, exit_status, env);
			write(pipefd[1], line, ft_strlen(line));
			write(pipefd[1], "\n", 1);
			free(line);
		}
		if (line)
			free(line);
		close(pipefd[1]);
		exit(0);
	}
	close(pipefd[1]);
	signal(SIGINT, SIG_IGN);
	waitpid(pid, &status, 0);
	if (WIFSIGNALED(status))
		if (WTERMSIG(status) == SIGINT)
			return (close(pipefd[0]), write(2, "\n", 1), -130);
	return (pipefd[0]);
}

void	open_all_heredocs(t_cmd *cmd, t_files *env, int *exit_status)
{
	t_redir	*r;

	while (cmd)
	{
		cmd->heredoc_fd = 0;
		r = cmd->redir_list;
		while (r)
		{
			if (cmd->heredoc_fd)
				close(cmd->heredoc_fd);
			cmd->heredoc_fd = 0;
			if (r->type == REDIR_HEREDOC)
				cmd->heredoc_fd = pipe_heredoc(r->filename, env, *exit_status, r->in_quote);
			if (cmd->heredoc_fd < 0)
			{
				*exit_status = -cmd->heredoc_fd;
				return ;
			}
			r = r->next;
		}
		cmd = cmd->next;
	}
}

int	check_files(t_redir *list)
{
	int	fd;

	fd = 0;
	while (list)
	{
		if (list->type == REDIR_INPUT)
			fd = open(list->filename, O_RDONLY);
		else if (list->type == REDIR_OUTPUT)
			fd = open(list->filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (list->type == REDIR_APPEND)
			fd = open(list->filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
		if (fd < 0)
			return (perror("open"), 1);
		if (fd)
			close(fd);
		list = list->next;
	}
	return (0);
}

int	redirect_io(t_redir *list)
{
	int	fd;

	fd = 0;
	while (list)
	{
		if (list->type == REDIR_INPUT)
			fd = open(list->filename, O_RDONLY);
		else if (list->type == REDIR_OUTPUT)
			fd = open(list->filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (list->type == REDIR_APPEND)
			fd = open(list->filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
		if (fd < 0)
			return (perror("open"), 1);
		if (list->type == REDIR_INPUT)
			if (dup2(fd, STDIN_FILENO) == -1)
				return (perror("dup2"), 1);
		if (list->type == REDIR_OUTPUT || list->type == REDIR_APPEND)
			if (dup2(fd, STDOUT_FILENO) == -1)
				return (perror("dup2"), 1);
		if (fd)
			close(fd);
		list = list->next;
	}
	return (0);
}

int	execute_pipeline(t_cmd *cmds, t_cmd *cmd, t_files **env, int *exit_status)
{
	t_exec_data	data;
	int			num_cmds;
	int			i;

	num_cmds = count_pipeline_cmds(cmd);
	if (num_cmds == 1 && is_builtin_without_output(cmd))
	{
		if (cmd->heredoc_fd)
			close (cmd->heredoc_fd);
		if (!check_files(cmd->redir_list) && cmd->argv)
			*exit_status = exec_builtin_no_output(cmds, cmd, env, *exit_status);
		return (*exit_status);
	}
	data.pipe_fds = malloc(sizeof(int) * 2 * (num_cmds - 1));
	if (!data.pipe_fds)
		return (perror("malloc"), 1);
	i = -1;
	while (++i < num_cmds - 1)
		if (pipe(data.pipe_fds + i * 2) == -1)
			return (perror("pipe"), close_pipes(&data, i), 1);
	data.num_pids = -1;
	while (cmd && (++data.num_pids < num_cmds))
	{
		data.pid[data.num_pids] = fork();
		if (data.pid[data.num_pids] == -1)
		{
			perror("fork");
			close_pipes(&data, num_cmds - 1);
			wait_for_children(&data);
			return (1);
		}
		if (data.pid[data.num_pids] == 0)
		{
			if (data.num_pids > 0)
				if (dup2(data.pipe_fds[(data.num_pids - 1) * 2], 0) == -1)
					exit_child("dup2:", &data, num_cmds, env);
			if (data.num_pids < num_cmds - 1)
				if (dup2(data.pipe_fds[data.num_pids * 2 + 1], 1) == -1)
					exit_child("dup2:", &data, num_cmds, env);
			close_pipes(&data, num_cmds - 1);
			*exit_status = redirect_io(cmd->redir_list);
			printf("%d\n", cmd->heredoc_fd);
			if (fcntl(cmd->heredoc_fd, F_GETFD) == -1)
        		perror("FD no estÃ¡ abierto\n");
			if (cmd->heredoc_fd)
			{
				if (dup2(cmd->heredoc_fd, 1) == -1)
					exit_child("dup2:", &data, num_cmds, env);
				close(cmd->heredoc_fd);
			}
			printf("%d\n", cmd->heredoc_fd);
			if (*exit_status)
			{
				free_lst(env);
				exit(*exit_status);
			}
			if (!cmd->argv)
				exit(0);
			signal(SIGINT, SIG_DFL);
			signal(SIGQUIT, SIG_DFL);
			if (is_builtin(cmd))
				exit(exec_builtin(cmds, cmd, env, *exit_status));
			else
				exec_command(cmd->argv, *env);
		}
		cmd = cmd->next;
	}
	close_pipes(&data, num_cmds - 1);
	signal(SIGINT, SIG_IGN);
	return (wait_for_children(&data));
}

void	exec_commands(t_cmd *cmd_list, t_files **env, int *exit_status)
{
	t_cmd	*cmd;

	cmd = cmd_list;
	open_all_heredocs(cmd_list, *env, exit_status);
	if (*exit_status)
		return ;
	while (cmd)
	{
		expand_pipeline_exit_status(cmd, *exit_status);
		*exit_status = execute_pipeline(cmd_list, cmd, env, exit_status);
		while (cmd && cmd->connector == PIPE)
			cmd = cmd->next;
		while (cmd && ((cmd->connector == AND && *exit_status != 0)
				|| (cmd->connector == OR && *exit_status == 0)))
			cmd = cmd->next;
		if (cmd)
			cmd = cmd->next;
	}
}
